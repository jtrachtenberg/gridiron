<html>
  <head>
    <style>
      body {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(3, 100px);
        grid-template-rows: repeat(3, 100px);
        grid-gap: 10px;
      }

      .arrow {
        width: 0;
        height: 0;
        border-left: 50px solid transparent;
        border-right: 50px solid transparent;
        border-top: 100px solid black;
      }

      .piece {
        width: 50px;
        height: 50px;
        border-radius: 25px;
        background-color: red;
      }

      .up .arrow {
        transform: rotate(90deg);
      }

      .right .arrow {
        transform: rotate(180deg);
      }

      .down .arrow {
        transform: rotate(270deg);
      }
    </style>
  </head>
  <body>
    <div class="grid">
      <div class="arrow up" onclick="rotateArrow(this)"></div>
      <div class="arrow up" onclick="rotateArrow(this)"></div>
      <div class="arrow up" onclick="rotateArrow(this)"></div>
      <div class="arrow up" onclick="rotateArrow(this)"></div>
      <div class="arrow up" onclick="rotateArrow(this)"></div>
      <div class="arrow up" onclick="rotateArrow(this)"></div>
      <div class="arrow up" onclick="rotateArrow(this)"></div>
      <div class="arrow up" onclick="rotateArrow(this)"></div>
      <div class="arrow up" onclick="rotateArrow(this)"></div>
    </div>
    <div class="piece" onclick="movePiece(this)"></div>
    <script>
      function rotateArrow(arrow) {
        const currentDirection = arrow.classList[1];
        let nextDirection;
        switch (currentDirection) {
          case "up":
            nextDirection = "right";
            break;
          case "right":
            nextDirection = "down";
            break;
          case "down":
            nextDirection = "left";
            break;
          case "left":
            nextDirection = "up";
            break;
        }
        arrow.classList.remove(currentDirection);
        arrow.classList.add(nextDirection);
      }

      function movePiece(piece) {
        const grid = document.querySelector(".grid");
        const gridRect = grid.getBoundingClientRect();
        const pieceRect = piece.getBoundingClientRect();
        const gridX = Math.floor((pieceRect.x - gridRect.x) / 110);
        const gridY = Math.floor((piece
                                  
// Create grid
const grid = [
[0, 0, 0, 0, 0],
[0, 0, 0, 0, 0],
[0, 0, 0, 0, 0],
[0, 0, 0, 0, 0],
[0, 0, 0, 0, 0]
];

// Create arrows at each grid intersection
const arrows = [
[1, 2, 3, 4, 5],
[1, 2, 3, 4, 5],
[1, 2, 3, 4, 5],
[1, 2, 3, 4, 5],
[1, 2, 3, 4, 5]
];

// Create round pieces
const pieces = [
{ x: 0, y: 0, direction: 0 },
{ x: 4, y: 4, direction: 0 }
];

// Click handler for arrows
const handleClick = (x, y) => {
// Spin arrow clockwise
arrows[x][y] = (arrows[x][y] + 1) % 4;
};

// Move pieces
const movePieces = () => {
pieces.forEach(piece => {
// Get current arrow at piece's location
const arrow = arrows[piece.x][piece.y];  
  
// Update piece's direction based on current arrow
switch (arrow) {
  case 0:
    piece.direction = (piece.direction + 3) % 4;
    break;
  case 1:
    piece.direction = (piece.direction + 0) % 4;
    break;
  case 2:
    piece.direction = (piece.direction + 1) % 4;
    break;
  case 3:
    piece.direction = (piece.direction + 2) % 4;
    break;
}

// Move piece based on updated direction
switch (piece.direction) {
  case 0:
    piece.y--;
    break;
  case 1:
    piece.x++;
    break;
  case 2:
    piece.y++;
    break;
  case 3:
    piece.x--;
    break;
}

  });
};

// Game loop
setInterval(() => {
movePieces();
}, 1000);
